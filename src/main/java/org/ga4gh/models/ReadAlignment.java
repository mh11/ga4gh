/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.ga4gh.models;  
@SuppressWarnings("all")
/** Each read alignment describes an alignment with additional information
about the fragment and the read. A read alignment object is equivalent to a
line in a SAM file. */
@org.apache.avro.specific.AvroGenerated
public class ReadAlignment extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"ReadAlignment\",\"namespace\":\"org.ga4gh.models\",\"doc\":\"Each read alignment describes an alignment with additional information\\nabout the fragment and the read. A read alignment object is equivalent to a\\nline in a SAM file.\",\"fields\":[{\"name\":\"id\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"The read alignment ID. This ID is unique within the read group this\\n  alignment belongs to.\\n\\n  For performance reasons, this field may be omitted by a backend.\\n  If provided, its intended use is to make caching and UI display easier for\\n  genome browsers and other lightweight clients.\"},{\"name\":\"readGroupId\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"The ID of the read group this read belongs to.\\n  (Every read must belong to exactly one read group.)\"},{\"name\":\"fragmentName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"The fragment name. Equivalent to QNAME (query template name) in SAM.\"},{\"name\":\"properPlacement\",\"type\":[\"null\",\"boolean\"],\"doc\":\"The orientation and the distance between reads from the fragment are\\n  consistent with the sequencing protocol (equivalent to SAM flag 0x2)\",\"default\":null},{\"name\":\"duplicateFragment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"The fragment is a PCR or optical duplicate (SAM flag 0x400).\",\"default\":null},{\"name\":\"numberReads\",\"type\":[\"null\",\"int\"],\"doc\":\"The number of reads in the fragment (extension to SAM flag 0x1)\",\"default\":null},{\"name\":\"fragmentLength\",\"type\":[\"null\",\"int\"],\"doc\":\"The observed length of the fragment, equivalent to TLEN in SAM.\",\"default\":null},{\"name\":\"readNumber\",\"type\":[\"null\",\"int\"],\"doc\":\"The read ordinal in the fragment, 0-based and less than numberReads. This\\n  field replaces SAM flag 0x40 and 0x80 and is intended to more cleanly\\n  represent multiple reads per fragment.\",\"default\":null},{\"name\":\"failedVendorQualityChecks\",\"type\":[\"null\",\"boolean\"],\"doc\":\"The read fails platform or vendor quality checks (SAM flag 0x200).\",\"default\":null},{\"name\":\"alignment\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"LinearAlignment\",\"doc\":\"A linear alignment describes the alignment of a read to a Reference, using a\\nposition and CIGAR array.\",\"fields\":[{\"name\":\"position\",\"type\":{\"type\":\"record\",\"name\":\"Position\",\"doc\":\"A `Position` is an unoriented base in some `Reference`. A `Position` is\\nrepresented by a `Reference` name, and a base number on that `Reference`\\n(0-based).\",\"fields\":[{\"name\":\"referenceName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"doc\":\"The name of the `Reference` on which the `Position` is located.\"},{\"name\":\"position\",\"type\":\"long\",\"doc\":\"The 0-based offset from the start of the forward strand for that `Reference`.\\n  Genomic positions are non-negative integers less than `Reference` length.\"},{\"name\":\"strand\",\"type\":{\"type\":\"enum\",\"name\":\"Strand\",\"doc\":\"Indicates the DNA strand associate for some data item.\\n* `NEG_STRAND`: The negative (-) strand.\\n* `POS_STRAND`:  The postive (+) strand.\",\"symbols\":[\"NEG_STRAND\",\"POS_STRAND\"]},\"doc\":\"Strand the position is associated with.\"}]},\"doc\":\"The position of this alignment.\"},{\"name\":\"mappingQuality\",\"type\":[\"null\",\"int\"],\"doc\":\"The mapping quality of this alignment, meaning the likelihood that the read\\n  maps to this position.\\n\\n  Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to the\\n  nearest integer.\",\"default\":null},{\"name\":\"cigar\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"CigarUnit\",\"doc\":\"A structure for an instance of a CIGAR operation.\\n`FIXME: This belongs under Reads (only readAlignment refers to this)`\",\"fields\":[{\"name\":\"operation\",\"type\":{\"type\":\"enum\",\"name\":\"CigarOperation\",\"doc\":\"An enum for the different types of CIGAR alignment operations that exist.\\nUsed wherever CIGAR alignments are used. The different enumerated values\\nhave the following usage:\\n\\n* `ALIGNMENT_MATCH`: An alignment match indicates that a sequence can be\\n  aligned to the reference without evidence of an INDEL. Unlike the\\n  `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the `ALIGNMENT_MATCH`\\n  operator does not indicate whether the reference and read sequences are an\\n  exact match. This operator is equivalent to SAM's `M`.\\n* `INSERT`: The insert operator indicates that the read contains evidence of\\n  bases being inserted into the reference. This operator is equivalent to\\n  SAM's `I`.\\n* `DELETE`: The delete operator indicates that the read contains evidence of\\n  bases being deleted from the reference. This operator is equivalent to\\n  SAM's `D`.\\n* `SKIP`: The skip operator indicates that this read skips a long segment of\\n  the reference, but the bases have not been deleted. This operator is\\n  commonly used when working with RNA-seq data, where reads may skip long\\n  segments of the reference between exons. This operator is equivalent to\\n  SAM's 'N'.\\n* `CLIP_SOFT`: The soft clip operator indicates that bases at the start/end\\n  of a read have not been considered during alignment. This may occur if the\\n  majority of a read maps, except for low quality bases at the start/end of\\n  a read. This operator is equivalent to SAM's 'S'. Bases that are soft clipped\\n  will still be stored in the read.\\n* `CLIP_HARD`: The hard clip operator indicates that bases at the start/end of\\n  a read have been omitted from this alignment. This may occur if this linear\\n  alignment is part of a chimeric alignment, or if the read has been trimmed\\n  (e.g., during error correction, or to trim poly-A tails for RNA-seq). This\\n  operator is equivalent to SAM's 'H'.\\n* `PAD`: The pad operator indicates that there is padding in an alignment.\\n  This operator is equivalent to SAM's 'P'.\\n* `SEQUENCE_MATCH`: This operator indicates that this portion of the aligned\\n  sequence exactly matches the reference (e.g., all bases are equal to the\\n  reference bases). This operator is equivalent to SAM's '='.\\n* `SEQUENCE_MISMATCH`: This operator indicates that this portion of the\\n  aligned sequence is an alignment match to the reference, but a sequence\\n  mismatch (e.g., the bases are not equal to the reference). This can\\n  indicate a SNP or a read error. This operator is equivalent to SAM's 'X'.\",\"symbols\":[\"ALIGNMENT_MATCH\",\"INSERT\",\"DELETE\",\"SKIP\",\"CLIP_SOFT\",\"CLIP_HARD\",\"PAD\",\"SEQUENCE_MATCH\",\"SEQUENCE_MISMATCH\"]},\"doc\":\"The operation type.\"},{\"name\":\"operationLength\",\"type\":\"long\",\"doc\":\"The number of bases that the operation runs for.\"},{\"name\":\"referenceSequence\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"`referenceSequence` is only used at mismatches (`SEQUENCE_MISMATCH`)\\n  and deletions (`DELETE`). Filling this field replaces the MD tag.\\n  If the relevant information is not available, leave this field as `null`.\",\"default\":null}]}},\"doc\":\"Represents the local alignment of this sequence (alignment matches, indels, etc)\\n  versus the reference.\",\"default\":[]}]}],\"doc\":\"The alignment for this alignment record. This field will be null if the read\\n  is unmapped.\",\"default\":null},{\"name\":\"secondaryAlignment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Whether this alignment is secondary. Equivalent to SAM flag 0x100.\\n  A secondary alignment represents an alternative to the primary alignment\\n  for this read. Aligners may return secondary alignments if a read can map\\n  ambiguously to multiple coordinates in the genome.\\n\\n  By convention, each read has one and only one alignment where both\\n  secondaryAlignment and supplementaryAlignment are false.\",\"default\":null},{\"name\":\"supplementaryAlignment\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Whether this alignment is supplementary. Equivalent to SAM flag 0x800.\\n  Supplementary alignments are used in the representation of a chimeric\\n  alignment. In a chimeric alignment, a read is split into multiple\\n  linear alignments that map to different reference contigs. The first\\n  linear alignment in the read will be designated as the representative alignment;\\n  the remaining linear alignments will be designated as supplementary alignments.\\n  These alignments may have different mapping quality scores.\\n\\n  In each linear alignment in a chimeric alignment, the read will be hard clipped",".\\n  The `alignedSequence` and `alignedQuality` fields in the alignment record will\\n  only represent the bases for its respective linear alignment.\",\"default\":null},{\"name\":\"alignedSequence\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"doc\":\"The bases of the read sequence contained in this alignment record (equivalent\\n  to SEQ in SAM).\\n\\n  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence\\n  and quality. This will occur if the alignment is part of a chimeric alignment,\\n  or if the read was trimmed. When this occurs, the CIGAR for this read will\\n  begin/end with a hard clip operator that will indicate the length of the\\n  excised sequence.\",\"default\":null},{\"name\":\"alignedQuality\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"The quality of the read sequence contained in this alignment record\\n  (equivalent to QUAL in SAM).\\n\\n  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence\\n  and quality. This will occur if the alignment is part of a chimeric alignment,\\n  or if the read was trimmed. When this occurs, the CIGAR for this read will\\n  begin/end with a hard clip operator that will indicate the length of the excised sequence.\",\"default\":[]},{\"name\":\"nextMatePosition\",\"type\":[\"null\",\"Position\"],\"doc\":\"The mapping of the primary alignment of the `(readNumber+1)%numberReads`\\n  read in the fragment. It replaces mate position and mate strand in SAM.\",\"default\":null},{\"name\":\"info\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},\"avro.java.string\":\"String\"},\"doc\":\"A map of additional read alignment information.\",\"default\":{}}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The read alignment ID. This ID is unique within the read group this
  alignment belongs to.

  For performance reasons, this field may be omitted by a backend.
  If provided, its intended use is to make caching and UI display easier for
  genome browsers and other lightweight clients. */
   private java.lang.String id;
  /** The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.) */
   private java.lang.String readGroupId;
  /** The fragment name. Equivalent to QNAME (query template name) in SAM. */
   private java.lang.String fragmentName;
  /** The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (equivalent to SAM flag 0x2) */
   private java.lang.Boolean properPlacement;
  /** The fragment is a PCR or optical duplicate (SAM flag 0x400). */
   private java.lang.Boolean duplicateFragment;
  /** The number of reads in the fragment (extension to SAM flag 0x1) */
   private java.lang.Integer numberReads;
  /** The observed length of the fragment, equivalent to TLEN in SAM. */
   private java.lang.Integer fragmentLength;
  /** The read ordinal in the fragment, 0-based and less than numberReads. This
  field replaces SAM flag 0x40 and 0x80 and is intended to more cleanly
  represent multiple reads per fragment. */
   private java.lang.Integer readNumber;
  /** The read fails platform or vendor quality checks (SAM flag 0x200). */
   private java.lang.Boolean failedVendorQualityChecks;
  /** The alignment for this alignment record. This field will be null if the read
  is unmapped. */
   private org.ga4gh.models.LinearAlignment alignment;
  /** Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false. */
   private java.lang.Boolean secondaryAlignment;
  /** Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment. */
   private java.lang.Boolean supplementaryAlignment;
  /** The bases of the read sequence contained in this alignment record (equivalent
  to SEQ in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the
  excised sequence. */
   private java.lang.String alignedSequence;
  /** The quality of the read sequence contained in this alignment record
  (equivalent to QUAL in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence. */
   private java.util.List<java.lang.Integer> alignedQuality;
  /** The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM. */
   private org.ga4gh.models.Position nextMatePosition;
  /** A map of additional read alignment information. */
   private java.util.Map<java.lang.String,java.util.List<java.lang.String>> info;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public ReadAlignment() {}

  /**
   * All-args constructor.
   */
  public ReadAlignment(java.lang.String id, java.lang.String readGroupId, java.lang.String fragmentName, java.lang.Boolean properPlacement, java.lang.Boolean duplicateFragment, java.lang.Integer numberReads, java.lang.Integer fragmentLength, java.lang.Integer readNumber, java.lang.Boolean failedVendorQualityChecks, org.ga4gh.models.LinearAlignment alignment, java.lang.Boolean secondaryAlignment, java.lang.Boolean supplementaryAlignment, java.lang.String alignedSequence, java.util.List<java.lang.Integer> alignedQuality, org.ga4gh.models.Position nextMatePosition, java.util.Map<java.lang.String,java.util.List<java.lang.String>> info) {
    this.id = id;
    this.readGroupId = readGroupId;
    this.fragmentName = fragmentName;
    this.properPlacement = properPlacement;
    this.duplicateFragment = duplicateFragment;
    this.numberReads = numberReads;
    this.fragmentLength = fragmentLength;
    this.readNumber = readNumber;
    this.failedVendorQualityChecks = failedVendorQualityChecks;
    this.alignment = alignment;
    this.secondaryAlignment = secondaryAlignment;
    this.supplementaryAlignment = supplementaryAlignment;
    this.alignedSequence = alignedSequence;
    this.alignedQuality = alignedQuality;
    this.nextMatePosition = nextMatePosition;
    this.info = info;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return id;
    case 1: return readGroupId;
    case 2: return fragmentName;
    case 3: return properPlacement;
    case 4: return duplicateFragment;
    case 5: return numberReads;
    case 6: return fragmentLength;
    case 7: return readNumber;
    case 8: return failedVendorQualityChecks;
    case 9: return alignment;
    case 10: return secondaryAlignment;
    case 11: return supplementaryAlignment;
    case 12: return alignedSequence;
    case 13: return alignedQuality;
    case 14: return nextMatePosition;
    case 15: return info;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: id = (java.lang.String)value$; break;
    case 1: readGroupId = (java.lang.String)value$; break;
    case 2: fragmentName = (java.lang.String)value$; break;
    case 3: properPlacement = (java.lang.Boolean)value$; break;
    case 4: duplicateFragment = (java.lang.Boolean)value$; break;
    case 5: numberReads = (java.lang.Integer)value$; break;
    case 6: fragmentLength = (java.lang.Integer)value$; break;
    case 7: readNumber = (java.lang.Integer)value$; break;
    case 8: failedVendorQualityChecks = (java.lang.Boolean)value$; break;
    case 9: alignment = (org.ga4gh.models.LinearAlignment)value$; break;
    case 10: secondaryAlignment = (java.lang.Boolean)value$; break;
    case 11: supplementaryAlignment = (java.lang.Boolean)value$; break;
    case 12: alignedSequence = (java.lang.String)value$; break;
    case 13: alignedQuality = (java.util.List<java.lang.Integer>)value$; break;
    case 14: nextMatePosition = (org.ga4gh.models.Position)value$; break;
    case 15: info = (java.util.Map<java.lang.String,java.util.List<java.lang.String>>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'id' field.
   * The read alignment ID. This ID is unique within the read group this
  alignment belongs to.

  For performance reasons, this field may be omitted by a backend.
  If provided, its intended use is to make caching and UI display easier for
  genome browsers and other lightweight clients.   */
  public java.lang.String getId() {
    return id;
  }

  /**
   * Sets the value of the 'id' field.
   * The read alignment ID. This ID is unique within the read group this
  alignment belongs to.

  For performance reasons, this field may be omitted by a backend.
  If provided, its intended use is to make caching and UI display easier for
  genome browsers and other lightweight clients.   * @param value the value to set.
   */
  public void setId(java.lang.String value) {
    this.id = value;
  }

  /**
   * Gets the value of the 'readGroupId' field.
   * The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.)   */
  public java.lang.String getReadGroupId() {
    return readGroupId;
  }

  /**
   * Sets the value of the 'readGroupId' field.
   * The ID of the read group this read belongs to.
  (Every read must belong to exactly one read group.)   * @param value the value to set.
   */
  public void setReadGroupId(java.lang.String value) {
    this.readGroupId = value;
  }

  /**
   * Gets the value of the 'fragmentName' field.
   * The fragment name. Equivalent to QNAME (query template name) in SAM.   */
  public java.lang.String getFragmentName() {
    return fragmentName;
  }

  /**
   * Sets the value of the 'fragmentName' field.
   * The fragment name. Equivalent to QNAME (query template name) in SAM.   * @param value the value to set.
   */
  public void setFragmentName(java.lang.String value) {
    this.fragmentName = value;
  }

  /**
   * Gets the value of the 'properPlacement' field.
   * The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (equivalent to SAM flag 0x2)   */
  public java.lang.Boolean getProperPlacement() {
    return properPlacement;
  }

  /**
   * Sets the value of the 'properPlacement' field.
   * The orientation and the distance between reads from the fragment are
  consistent with the sequencing protocol (equivalent to SAM flag 0x2)   * @param value the value to set.
   */
  public void setProperPlacement(java.lang.Boolean value) {
    this.properPlacement = value;
  }

  /**
   * Gets the value of the 'duplicateFragment' field.
   * The fragment is a PCR or optical duplicate (SAM flag 0x400).   */
  public java.lang.Boolean getDuplicateFragment() {
    return duplicateFragment;
  }

  /**
   * Sets the value of the 'duplicateFragment' field.
   * The fragment is a PCR or optical duplicate (SAM flag 0x400).   * @param value the value to set.
   */
  public void setDuplicateFragment(java.lang.Boolean value) {
    this.duplicateFragment = value;
  }

  /**
   * Gets the value of the 'numberReads' field.
   * The number of reads in the fragment (extension to SAM flag 0x1)   */
  public java.lang.Integer getNumberReads() {
    return numberReads;
  }

  /**
   * Sets the value of the 'numberReads' field.
   * The number of reads in the fragment (extension to SAM flag 0x1)   * @param value the value to set.
   */
  public void setNumberReads(java.lang.Integer value) {
    this.numberReads = value;
  }

  /**
   * Gets the value of the 'fragmentLength' field.
   * The observed length of the fragment, equivalent to TLEN in SAM.   */
  public java.lang.Integer getFragmentLength() {
    return fragmentLength;
  }

  /**
   * Sets the value of the 'fragmentLength' field.
   * The observed length of the fragment, equivalent to TLEN in SAM.   * @param value the value to set.
   */
  public void setFragmentLength(java.lang.Integer value) {
    this.fragmentLength = value;
  }

  /**
   * Gets the value of the 'readNumber' field.
   * The read ordinal in the fragment, 0-based and less than numberReads. This
  field replaces SAM flag 0x40 and 0x80 and is intended to more cleanly
  represent multiple reads per fragment.   */
  public java.lang.Integer getReadNumber() {
    return readNumber;
  }

  /**
   * Sets the value of the 'readNumber' field.
   * The read ordinal in the fragment, 0-based and less than numberReads. This
  field replaces SAM flag 0x40 and 0x80 and is intended to more cleanly
  represent multiple reads per fragment.   * @param value the value to set.
   */
  public void setReadNumber(java.lang.Integer value) {
    this.readNumber = value;
  }

  /**
   * Gets the value of the 'failedVendorQualityChecks' field.
   * The read fails platform or vendor quality checks (SAM flag 0x200).   */
  public java.lang.Boolean getFailedVendorQualityChecks() {
    return failedVendorQualityChecks;
  }

  /**
   * Sets the value of the 'failedVendorQualityChecks' field.
   * The read fails platform or vendor quality checks (SAM flag 0x200).   * @param value the value to set.
   */
  public void setFailedVendorQualityChecks(java.lang.Boolean value) {
    this.failedVendorQualityChecks = value;
  }

  /**
   * Gets the value of the 'alignment' field.
   * The alignment for this alignment record. This field will be null if the read
  is unmapped.   */
  public org.ga4gh.models.LinearAlignment getAlignment() {
    return alignment;
  }

  /**
   * Sets the value of the 'alignment' field.
   * The alignment for this alignment record. This field will be null if the read
  is unmapped.   * @param value the value to set.
   */
  public void setAlignment(org.ga4gh.models.LinearAlignment value) {
    this.alignment = value;
  }

  /**
   * Gets the value of the 'secondaryAlignment' field.
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false.   */
  public java.lang.Boolean getSecondaryAlignment() {
    return secondaryAlignment;
  }

  /**
   * Sets the value of the 'secondaryAlignment' field.
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
  A secondary alignment represents an alternative to the primary alignment
  for this read. Aligners may return secondary alignments if a read can map
  ambiguously to multiple coordinates in the genome.

  By convention, each read has one and only one alignment where both
  secondaryAlignment and supplementaryAlignment are false.   * @param value the value to set.
   */
  public void setSecondaryAlignment(java.lang.Boolean value) {
    this.secondaryAlignment = value;
  }

  /**
   * Gets the value of the 'supplementaryAlignment' field.
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment.   */
  public java.lang.Boolean getSupplementaryAlignment() {
    return supplementaryAlignment;
  }

  /**
   * Sets the value of the 'supplementaryAlignment' field.
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
  Supplementary alignments are used in the representation of a chimeric
  alignment. In a chimeric alignment, a read is split into multiple
  linear alignments that map to different reference contigs. The first
  linear alignment in the read will be designated as the representative alignment;
  the remaining linear alignments will be designated as supplementary alignments.
  These alignments may have different mapping quality scores.

  In each linear alignment in a chimeric alignment, the read will be hard clipped.
  The `alignedSequence` and `alignedQuality` fields in the alignment record will
  only represent the bases for its respective linear alignment.   * @param value the value to set.
   */
  public void setSupplementaryAlignment(java.lang.Boolean value) {
    this.supplementaryAlignment = value;
  }

  /**
   * Gets the value of the 'alignedSequence' field.
   * The bases of the read sequence contained in this alignment record (equivalent
  to SEQ in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the
  excised sequence.   */
  public java.lang.String getAlignedSequence() {
    return alignedSequence;
  }

  /**
   * Sets the value of the 'alignedSequence' field.
   * The bases of the read sequence contained in this alignment record (equivalent
  to SEQ in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the
  excised sequence.   * @param value the value to set.
   */
  public void setAlignedSequence(java.lang.String value) {
    this.alignedSequence = value;
  }

  /**
   * Gets the value of the 'alignedQuality' field.
   * The quality of the read sequence contained in this alignment record
  (equivalent to QUAL in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   */
  public java.util.List<java.lang.Integer> getAlignedQuality() {
    return alignedQuality;
  }

  /**
   * Sets the value of the 'alignedQuality' field.
   * The quality of the read sequence contained in this alignment record
  (equivalent to QUAL in SAM).

  `alignedSequence` and `alignedQuality` may be shorter than the full read sequence
  and quality. This will occur if the alignment is part of a chimeric alignment,
  or if the read was trimmed. When this occurs, the CIGAR for this read will
  begin/end with a hard clip operator that will indicate the length of the excised sequence.   * @param value the value to set.
   */
  public void setAlignedQuality(java.util.List<java.lang.Integer> value) {
    this.alignedQuality = value;
  }

  /**
   * Gets the value of the 'nextMatePosition' field.
   * The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM.   */
  public org.ga4gh.models.Position getNextMatePosition() {
    return nextMatePosition;
  }

  /**
   * Sets the value of the 'nextMatePosition' field.
   * The mapping of the primary alignment of the `(readNumber+1)%numberReads`
  read in the fragment. It replaces mate position and mate strand in SAM.   * @param value the value to set.
   */
  public void setNextMatePosition(org.ga4gh.models.Position value) {
    this.nextMatePosition = value;
  }

  /**
   * Gets the value of the 'info' field.
   * A map of additional read alignment information.   */
  public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getInfo() {
    return info;
  }

  /**
   * Sets the value of the 'info' field.
   * A map of additional read alignment information.   * @param value the value to set.
   */
  public void setInfo(java.util.Map<java.lang.String,java.util.List<java.lang.String>> value) {
    this.info = value;
  }

  /** Creates a new ReadAlignment RecordBuilder */
  public static org.ga4gh.models.ReadAlignment.Builder newBuilder() {
    return new org.ga4gh.models.ReadAlignment.Builder();
  }
  
  /** Creates a new ReadAlignment RecordBuilder by copying an existing Builder */
  public static org.ga4gh.models.ReadAlignment.Builder newBuilder(org.ga4gh.models.ReadAlignment.Builder other) {
    return new org.ga4gh.models.ReadAlignment.Builder(other);
  }
  
  /** Creates a new ReadAlignment RecordBuilder by copying an existing ReadAlignment instance */
  public static org.ga4gh.models.ReadAlignment.Builder newBuilder(org.ga4gh.models.ReadAlignment other) {
    return new org.ga4gh.models.ReadAlignment.Builder(other);
  }
  
  /**
   * RecordBuilder for ReadAlignment instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<ReadAlignment>
    implements org.apache.avro.data.RecordBuilder<ReadAlignment> {

    private java.lang.String id;
    private java.lang.String readGroupId;
    private java.lang.String fragmentName;
    private java.lang.Boolean properPlacement;
    private java.lang.Boolean duplicateFragment;
    private java.lang.Integer numberReads;
    private java.lang.Integer fragmentLength;
    private java.lang.Integer readNumber;
    private java.lang.Boolean failedVendorQualityChecks;
    private org.ga4gh.models.LinearAlignment alignment;
    private java.lang.Boolean secondaryAlignment;
    private java.lang.Boolean supplementaryAlignment;
    private java.lang.String alignedSequence;
    private java.util.List<java.lang.Integer> alignedQuality;
    private org.ga4gh.models.Position nextMatePosition;
    private java.util.Map<java.lang.String,java.util.List<java.lang.String>> info;

    /** Creates a new Builder */
    private Builder() {
      super(org.ga4gh.models.ReadAlignment.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.ga4gh.models.ReadAlignment.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.readGroupId)) {
        this.readGroupId = data().deepCopy(fields()[1].schema(), other.readGroupId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.fragmentName)) {
        this.fragmentName = data().deepCopy(fields()[2].schema(), other.fragmentName);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properPlacement)) {
        this.properPlacement = data().deepCopy(fields()[3].schema(), other.properPlacement);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.duplicateFragment)) {
        this.duplicateFragment = data().deepCopy(fields()[4].schema(), other.duplicateFragment);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.numberReads)) {
        this.numberReads = data().deepCopy(fields()[5].schema(), other.numberReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.fragmentLength)) {
        this.fragmentLength = data().deepCopy(fields()[6].schema(), other.fragmentLength);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.readNumber)) {
        this.readNumber = data().deepCopy(fields()[7].schema(), other.readNumber);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[8].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alignment)) {
        this.alignment = data().deepCopy(fields()[9].schema(), other.alignment);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[10].schema(), other.secondaryAlignment);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[11].schema(), other.supplementaryAlignment);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.alignedSequence)) {
        this.alignedSequence = data().deepCopy(fields()[12].schema(), other.alignedSequence);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.alignedQuality)) {
        this.alignedQuality = data().deepCopy(fields()[13].schema(), other.alignedQuality);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.nextMatePosition)) {
        this.nextMatePosition = data().deepCopy(fields()[14].schema(), other.nextMatePosition);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.info)) {
        this.info = data().deepCopy(fields()[15].schema(), other.info);
        fieldSetFlags()[15] = true;
      }
    }
    
    /** Creates a Builder by copying an existing ReadAlignment instance */
    private Builder(org.ga4gh.models.ReadAlignment other) {
            super(org.ga4gh.models.ReadAlignment.SCHEMA$);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.readGroupId)) {
        this.readGroupId = data().deepCopy(fields()[1].schema(), other.readGroupId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.fragmentName)) {
        this.fragmentName = data().deepCopy(fields()[2].schema(), other.fragmentName);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properPlacement)) {
        this.properPlacement = data().deepCopy(fields()[3].schema(), other.properPlacement);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.duplicateFragment)) {
        this.duplicateFragment = data().deepCopy(fields()[4].schema(), other.duplicateFragment);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.numberReads)) {
        this.numberReads = data().deepCopy(fields()[5].schema(), other.numberReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.fragmentLength)) {
        this.fragmentLength = data().deepCopy(fields()[6].schema(), other.fragmentLength);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.readNumber)) {
        this.readNumber = data().deepCopy(fields()[7].schema(), other.readNumber);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[8].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alignment)) {
        this.alignment = data().deepCopy(fields()[9].schema(), other.alignment);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[10].schema(), other.secondaryAlignment);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[11].schema(), other.supplementaryAlignment);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.alignedSequence)) {
        this.alignedSequence = data().deepCopy(fields()[12].schema(), other.alignedSequence);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.alignedQuality)) {
        this.alignedQuality = data().deepCopy(fields()[13].schema(), other.alignedQuality);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.nextMatePosition)) {
        this.nextMatePosition = data().deepCopy(fields()[14].schema(), other.nextMatePosition);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.info)) {
        this.info = data().deepCopy(fields()[15].schema(), other.info);
        fieldSetFlags()[15] = true;
      }
    }

    /** Gets the value of the 'id' field */
    public java.lang.String getId() {
      return id;
    }
    
    /** Sets the value of the 'id' field */
    public org.ga4gh.models.ReadAlignment.Builder setId(java.lang.String value) {
      validate(fields()[0], value);
      this.id = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'id' field has been set */
    public boolean hasId() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'id' field */
    public org.ga4gh.models.ReadAlignment.Builder clearId() {
      id = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'readGroupId' field */
    public java.lang.String getReadGroupId() {
      return readGroupId;
    }
    
    /** Sets the value of the 'readGroupId' field */
    public org.ga4gh.models.ReadAlignment.Builder setReadGroupId(java.lang.String value) {
      validate(fields()[1], value);
      this.readGroupId = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'readGroupId' field has been set */
    public boolean hasReadGroupId() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'readGroupId' field */
    public org.ga4gh.models.ReadAlignment.Builder clearReadGroupId() {
      readGroupId = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'fragmentName' field */
    public java.lang.String getFragmentName() {
      return fragmentName;
    }
    
    /** Sets the value of the 'fragmentName' field */
    public org.ga4gh.models.ReadAlignment.Builder setFragmentName(java.lang.String value) {
      validate(fields()[2], value);
      this.fragmentName = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'fragmentName' field has been set */
    public boolean hasFragmentName() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'fragmentName' field */
    public org.ga4gh.models.ReadAlignment.Builder clearFragmentName() {
      fragmentName = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'properPlacement' field */
    public java.lang.Boolean getProperPlacement() {
      return properPlacement;
    }
    
    /** Sets the value of the 'properPlacement' field */
    public org.ga4gh.models.ReadAlignment.Builder setProperPlacement(java.lang.Boolean value) {
      validate(fields()[3], value);
      this.properPlacement = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'properPlacement' field has been set */
    public boolean hasProperPlacement() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'properPlacement' field */
    public org.ga4gh.models.ReadAlignment.Builder clearProperPlacement() {
      properPlacement = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'duplicateFragment' field */
    public java.lang.Boolean getDuplicateFragment() {
      return duplicateFragment;
    }
    
    /** Sets the value of the 'duplicateFragment' field */
    public org.ga4gh.models.ReadAlignment.Builder setDuplicateFragment(java.lang.Boolean value) {
      validate(fields()[4], value);
      this.duplicateFragment = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'duplicateFragment' field has been set */
    public boolean hasDuplicateFragment() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'duplicateFragment' field */
    public org.ga4gh.models.ReadAlignment.Builder clearDuplicateFragment() {
      duplicateFragment = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'numberReads' field */
    public java.lang.Integer getNumberReads() {
      return numberReads;
    }
    
    /** Sets the value of the 'numberReads' field */
    public org.ga4gh.models.ReadAlignment.Builder setNumberReads(java.lang.Integer value) {
      validate(fields()[5], value);
      this.numberReads = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'numberReads' field has been set */
    public boolean hasNumberReads() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'numberReads' field */
    public org.ga4gh.models.ReadAlignment.Builder clearNumberReads() {
      numberReads = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'fragmentLength' field */
    public java.lang.Integer getFragmentLength() {
      return fragmentLength;
    }
    
    /** Sets the value of the 'fragmentLength' field */
    public org.ga4gh.models.ReadAlignment.Builder setFragmentLength(java.lang.Integer value) {
      validate(fields()[6], value);
      this.fragmentLength = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'fragmentLength' field has been set */
    public boolean hasFragmentLength() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'fragmentLength' field */
    public org.ga4gh.models.ReadAlignment.Builder clearFragmentLength() {
      fragmentLength = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'readNumber' field */
    public java.lang.Integer getReadNumber() {
      return readNumber;
    }
    
    /** Sets the value of the 'readNumber' field */
    public org.ga4gh.models.ReadAlignment.Builder setReadNumber(java.lang.Integer value) {
      validate(fields()[7], value);
      this.readNumber = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'readNumber' field has been set */
    public boolean hasReadNumber() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'readNumber' field */
    public org.ga4gh.models.ReadAlignment.Builder clearReadNumber() {
      readNumber = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'failedVendorQualityChecks' field */
    public java.lang.Boolean getFailedVendorQualityChecks() {
      return failedVendorQualityChecks;
    }
    
    /** Sets the value of the 'failedVendorQualityChecks' field */
    public org.ga4gh.models.ReadAlignment.Builder setFailedVendorQualityChecks(java.lang.Boolean value) {
      validate(fields()[8], value);
      this.failedVendorQualityChecks = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'failedVendorQualityChecks' field has been set */
    public boolean hasFailedVendorQualityChecks() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'failedVendorQualityChecks' field */
    public org.ga4gh.models.ReadAlignment.Builder clearFailedVendorQualityChecks() {
      failedVendorQualityChecks = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'alignment' field */
    public org.ga4gh.models.LinearAlignment getAlignment() {
      return alignment;
    }
    
    /** Sets the value of the 'alignment' field */
    public org.ga4gh.models.ReadAlignment.Builder setAlignment(org.ga4gh.models.LinearAlignment value) {
      validate(fields()[9], value);
      this.alignment = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'alignment' field has been set */
    public boolean hasAlignment() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'alignment' field */
    public org.ga4gh.models.ReadAlignment.Builder clearAlignment() {
      alignment = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'secondaryAlignment' field */
    public java.lang.Boolean getSecondaryAlignment() {
      return secondaryAlignment;
    }
    
    /** Sets the value of the 'secondaryAlignment' field */
    public org.ga4gh.models.ReadAlignment.Builder setSecondaryAlignment(java.lang.Boolean value) {
      validate(fields()[10], value);
      this.secondaryAlignment = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryAlignment' field has been set */
    public boolean hasSecondaryAlignment() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'secondaryAlignment' field */
    public org.ga4gh.models.ReadAlignment.Builder clearSecondaryAlignment() {
      secondaryAlignment = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'supplementaryAlignment' field */
    public java.lang.Boolean getSupplementaryAlignment() {
      return supplementaryAlignment;
    }
    
    /** Sets the value of the 'supplementaryAlignment' field */
    public org.ga4gh.models.ReadAlignment.Builder setSupplementaryAlignment(java.lang.Boolean value) {
      validate(fields()[11], value);
      this.supplementaryAlignment = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'supplementaryAlignment' field has been set */
    public boolean hasSupplementaryAlignment() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'supplementaryAlignment' field */
    public org.ga4gh.models.ReadAlignment.Builder clearSupplementaryAlignment() {
      supplementaryAlignment = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'alignedSequence' field */
    public java.lang.String getAlignedSequence() {
      return alignedSequence;
    }
    
    /** Sets the value of the 'alignedSequence' field */
    public org.ga4gh.models.ReadAlignment.Builder setAlignedSequence(java.lang.String value) {
      validate(fields()[12], value);
      this.alignedSequence = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'alignedSequence' field has been set */
    public boolean hasAlignedSequence() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'alignedSequence' field */
    public org.ga4gh.models.ReadAlignment.Builder clearAlignedSequence() {
      alignedSequence = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'alignedQuality' field */
    public java.util.List<java.lang.Integer> getAlignedQuality() {
      return alignedQuality;
    }
    
    /** Sets the value of the 'alignedQuality' field */
    public org.ga4gh.models.ReadAlignment.Builder setAlignedQuality(java.util.List<java.lang.Integer> value) {
      validate(fields()[13], value);
      this.alignedQuality = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'alignedQuality' field has been set */
    public boolean hasAlignedQuality() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'alignedQuality' field */
    public org.ga4gh.models.ReadAlignment.Builder clearAlignedQuality() {
      alignedQuality = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'nextMatePosition' field */
    public org.ga4gh.models.Position getNextMatePosition() {
      return nextMatePosition;
    }
    
    /** Sets the value of the 'nextMatePosition' field */
    public org.ga4gh.models.ReadAlignment.Builder setNextMatePosition(org.ga4gh.models.Position value) {
      validate(fields()[14], value);
      this.nextMatePosition = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'nextMatePosition' field has been set */
    public boolean hasNextMatePosition() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'nextMatePosition' field */
    public org.ga4gh.models.ReadAlignment.Builder clearNextMatePosition() {
      nextMatePosition = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'info' field */
    public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getInfo() {
      return info;
    }
    
    /** Sets the value of the 'info' field */
    public org.ga4gh.models.ReadAlignment.Builder setInfo(java.util.Map<java.lang.String,java.util.List<java.lang.String>> value) {
      validate(fields()[15], value);
      this.info = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'info' field has been set */
    public boolean hasInfo() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'info' field */
    public org.ga4gh.models.ReadAlignment.Builder clearInfo() {
      info = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    @Override
    public ReadAlignment build() {
      try {
        ReadAlignment record = new ReadAlignment();
        record.id = fieldSetFlags()[0] ? this.id : (java.lang.String) defaultValue(fields()[0]);
        record.readGroupId = fieldSetFlags()[1] ? this.readGroupId : (java.lang.String) defaultValue(fields()[1]);
        record.fragmentName = fieldSetFlags()[2] ? this.fragmentName : (java.lang.String) defaultValue(fields()[2]);
        record.properPlacement = fieldSetFlags()[3] ? this.properPlacement : (java.lang.Boolean) defaultValue(fields()[3]);
        record.duplicateFragment = fieldSetFlags()[4] ? this.duplicateFragment : (java.lang.Boolean) defaultValue(fields()[4]);
        record.numberReads = fieldSetFlags()[5] ? this.numberReads : (java.lang.Integer) defaultValue(fields()[5]);
        record.fragmentLength = fieldSetFlags()[6] ? this.fragmentLength : (java.lang.Integer) defaultValue(fields()[6]);
        record.readNumber = fieldSetFlags()[7] ? this.readNumber : (java.lang.Integer) defaultValue(fields()[7]);
        record.failedVendorQualityChecks = fieldSetFlags()[8] ? this.failedVendorQualityChecks : (java.lang.Boolean) defaultValue(fields()[8]);
        record.alignment = fieldSetFlags()[9] ? this.alignment : (org.ga4gh.models.LinearAlignment) defaultValue(fields()[9]);
        record.secondaryAlignment = fieldSetFlags()[10] ? this.secondaryAlignment : (java.lang.Boolean) defaultValue(fields()[10]);
        record.supplementaryAlignment = fieldSetFlags()[11] ? this.supplementaryAlignment : (java.lang.Boolean) defaultValue(fields()[11]);
        record.alignedSequence = fieldSetFlags()[12] ? this.alignedSequence : (java.lang.String) defaultValue(fields()[12]);
        record.alignedQuality = fieldSetFlags()[13] ? this.alignedQuality : (java.util.List<java.lang.Integer>) defaultValue(fields()[13]);
        record.nextMatePosition = fieldSetFlags()[14] ? this.nextMatePosition : (org.ga4gh.models.Position) defaultValue(fields()[14]);
        record.info = fieldSetFlags()[15] ? this.info : (java.util.Map<java.lang.String,java.util.List<java.lang.String>>) defaultValue(fields()[15]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
