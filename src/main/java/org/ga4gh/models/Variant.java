/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.ga4gh.models;  
@SuppressWarnings("all")
/** A `Variant` represents a change in DNA sequence relative to some reference.
For example, a variant could represent a SNP or an insertion.
Variants belong to a `VariantSet`.
This is equivalent to a row in VCF. */
@org.apache.avro.specific.AvroGenerated
public class Variant extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Variant\",\"namespace\":\"org.ga4gh.models\",\"doc\":\"A `Variant` represents a change in DNA sequence relative to some reference.\\nFor example, a variant could represent a SNP or an insertion.\\nVariants belong to a `VariantSet`.\\nThis is equivalent to a row in VCF.\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"The variant ID.\"},{\"name\":\"variantSetId\",\"type\":\"string\",\"doc\":\"The ID of the variant set this variant belongs to.\"},{\"name\":\"names\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Names for the variant, for example a RefSNP ID.\",\"default\":[]},{\"name\":\"created\",\"type\":[\"null\",\"long\"],\"doc\":\"The date this variant was created in milliseconds from the epoch.\",\"default\":null},{\"name\":\"updated\",\"type\":[\"null\",\"long\"],\"doc\":\"The time at which this variant was last updated in\\n  milliseconds from the epoch.\",\"default\":null},{\"name\":\"referenceName\",\"type\":[\"null\",\"string\"],\"doc\":\"The reference on which this variant occurs.\\n  (e.g. `chr20` or `X`)\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"The start position at which this variant occurs (0-based).\\n  This corresponds to the first base of the string of reference bases.\\n  Genomic positions are non-negative integers less than reference length.\\n  Variants spanning the join of circular genomes are represented as\\n  two variants one on each side of the join (position 0).\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"The end position (exclusive), resulting in [start, end) closed-open interval.\\n  This is typically calculated by `start + referenceBases.length`.\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null},{\"name\":\"referenceBases\",\"type\":[\"null\",\"string\"],\"doc\":\"The reference bases for this variant. They occupy the range described by\\n  `referenceName`, `start`, and `end`, which all must be set if this field is\\n  set.\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null},{\"name\":\"alternateBases\",\"type\":[\"null\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"The bases that appear instead of the reference bases. If this field is not\\n  null, `referenceBases` must be set.\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null},{\"name\":\"alleleIds\",\"type\":[\"null\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"The IDs of the reference and alternate `Allele`s for this `Variant`. The first\\n  is the reference allele, and any others are alternates. If this field is set\\n  along with `referenceName`, `start`, `end`, `referenceBases`, and/or\\n  `alternateBases`, those fields must agree with the `Allele`s given here.\\n\\n  If the API server supports the \\\"graph\\\" mode, this field must not be null.\"},{\"name\":\"info\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":\"string\"}},\"doc\":\"A map of additional variant information.\",\"default\":{}},{\"name\":\"calls\",\"type\":[\"null\",{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"Call\",\"doc\":\"A `Call` represents the determination of genotype with respect to a\\nparticular `Variant`.\\n\\nIt may include associated information such as quality\\nand phasing. For example, a call might assign a probability of 0.32 to\\nthe occurrence of a SNP named rs1234 in a call set with the name NA12345.\\n\\nThe genotypes described by `Call`s must be consistent with any `AlleleCall`s in\\nthe same `CallSet`. If a server supports \\\"classic\\\" mode, it must provide `Call`s\\nfor all `Variant`s that have associated `AlleleCall`s in the `CallSet`.\",\"fields\":[{\"name\":\"callSetId\",\"type\":[\"null\",\"string\"],\"doc\":\"The ID of the call set this variant call belongs to.\\n  If this field is not present, the ordering of the call sets from a\\n  `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match\\n  the ordering of the calls on this `Variant`.\\n  The number of results will also be the same.\"},{\"name\":\"callSetName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of the call set this variant call belongs to.\\n  If this field is not present, the ordering of the call sets from a\\n  `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match\\n  the ordering of the calls on this `Variant`.\\n  The number of results will also be the same.\",\"default\":null},{\"name\":\"variantId\",\"type\":[\"null\",\"string\"],\"doc\":\"The ID of the `Variant` that this `Call` belongs to. Must be set in any `Call`\\n  that is not being returned from the server already contained within its\\n  `Variant`.\"},{\"name\":\"genotype\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"The genotype of this variant call.\\n\\n  A 0 value represents the reference allele of the associated `Variant`. Any\\n  other value is a 1-based index into the alternate alleles of the associated\\n  `Variant`.\\n\\n  If a variant had a referenceBases field of \\\"T\\\", an alternateBases\\n  value of [\\\"A\\\", \\\"C\\\"], and the genotype was [2, 1], that would mean the call\\n  represented the heterozygous value \\\"CA\\\" for this variant. If the genotype\\n  was instead [0, 1] the represented value would be \\\"TA\\\". Ordering of the\\n  genotype values is important if the phaseset field is present.\",\"default\":[]},{\"name\":\"phaseset\",\"type\":[\"null\",\"string\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"If this field is a string, this variant call's genotype ordering implies\\n  the phase of the bases and is consistent with any other variant calls on\\n  the same contig which have the same phaseset string.\\n\\n  If this field is an array, each entry is associated with the corresponding\\n  entry in the `genotype` array. Allele instances that are associated with the\\n  same `phaseset` string occur on the same molecule of DNA.\\n\\n  For example, if one `Call` has `genotype` [0, 1], another is associated with\\n  `Allele` 3, and both have a `phaseset` of [\\\"maternal\\\", \\\"paternal\\\"], then one\\n  DNA molecule carries 0, 3 and another carries 1, 3.\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be an\\n  array. If the API server supports the \\\"graph\\\" mode and not the \\\"classic\\\" mode,\\n  this field must be an array.\",\"default\":null},{\"name\":\"genotypeLikelihood\",\"type\":{\"type\":\"array\",\"items\":\"double\"},\"doc\":\"The genotype likelihoods for this variant call. Each array entry\\n  represents how likely a specific genotype is for this call as\\n  log10(P(data | genotype)), analogous to the GL tag in the VCF spec. The\\n  value ordering is defined by the GL tag in the VCF spec.\",\"default\":[]},{\"name\":\"info\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"array\",\"items\":\"string\"}},\"doc\":\"A map of additional variant call information.\",\"default\":{}}]}}],\"doc\":\"The variant calls for this particular variant. Each one represents the\\n  determination of genotype with respect to this variant. `Call`s in this array\\n  are implicitly associated with this `Variant`.\\n\\n  Calls are also available through the `searchCalls()` API method.\\n\\n  If the API server supports the \\\"classic\\\" mode, this field must not be null.\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The variant ID. */
   private java.lang.CharSequence id;
  /** The ID of the variant set this variant belongs to. */
   private java.lang.CharSequence variantSetId;
  /** Names for the variant, for example a RefSNP ID. */
   private java.util.List<java.lang.CharSequence> names;
  /** The date this variant was created in milliseconds from the epoch. */
   private java.lang.Long created;
  /** The time at which this variant was last updated in
  milliseconds from the epoch. */
   private java.lang.Long updated;
  /** The reference on which this variant occurs.
  (e.g. `chr20` or `X`)

  If the API server supports the "classic" mode, this field must not be null. */
   private java.lang.CharSequence referenceName;
  /** The start position at which this variant occurs (0-based).
  This corresponds to the first base of the string of reference bases.
  Genomic positions are non-negative integers less than reference length.
  Variants spanning the join of circular genomes are represented as
  two variants one on each side of the join (position 0).

  If the API server supports the "classic" mode, this field must not be null. */
   private java.lang.Long start;
  /** The end position (exclusive), resulting in [start, end) closed-open interval.
  This is typically calculated by `start + referenceBases.length`.

  If the API server supports the "classic" mode, this field must not be null. */
   private java.lang.Long end;
  /** The reference bases for this variant. They occupy the range described by
  `referenceName`, `start`, and `end`, which all must be set if this field is
  set.

  If the API server supports the "classic" mode, this field must not be null. */
   private java.lang.CharSequence referenceBases;
  /** The bases that appear instead of the reference bases. If this field is not
  null, `referenceBases` must be set.

  If the API server supports the "classic" mode, this field must not be null. */
   private java.util.List<java.lang.CharSequence> alternateBases;
  /** The IDs of the reference and alternate `Allele`s for this `Variant`. The first
  is the reference allele, and any others are alternates. If this field is set
  along with `referenceName`, `start`, `end`, `referenceBases`, and/or
  `alternateBases`, those fields must agree with the `Allele`s given here.

  If the API server supports the "graph" mode, this field must not be null. */
   private java.util.List<java.lang.CharSequence> alleleIds;
  /** A map of additional variant information. */
   private java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info;
  /** The variant calls for this particular variant. Each one represents the
  determination of genotype with respect to this variant. `Call`s in this array
  are implicitly associated with this `Variant`.

  Calls are also available through the `searchCalls()` API method.

  If the API server supports the "classic" mode, this field must not be null. */
   private java.util.List<org.ga4gh.models.Call> calls;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public Variant() {}

  /**
   * All-args constructor.
   */
  public Variant(java.lang.CharSequence id, java.lang.CharSequence variantSetId, java.util.List<java.lang.CharSequence> names, java.lang.Long created, java.lang.Long updated, java.lang.CharSequence referenceName, java.lang.Long start, java.lang.Long end, java.lang.CharSequence referenceBases, java.util.List<java.lang.CharSequence> alternateBases, java.util.List<java.lang.CharSequence> alleleIds, java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info, java.util.List<org.ga4gh.models.Call> calls) {
    this.id = id;
    this.variantSetId = variantSetId;
    this.names = names;
    this.created = created;
    this.updated = updated;
    this.referenceName = referenceName;
    this.start = start;
    this.end = end;
    this.referenceBases = referenceBases;
    this.alternateBases = alternateBases;
    this.alleleIds = alleleIds;
    this.info = info;
    this.calls = calls;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return id;
    case 1: return variantSetId;
    case 2: return names;
    case 3: return created;
    case 4: return updated;
    case 5: return referenceName;
    case 6: return start;
    case 7: return end;
    case 8: return referenceBases;
    case 9: return alternateBases;
    case 10: return alleleIds;
    case 11: return info;
    case 12: return calls;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: id = (java.lang.CharSequence)value$; break;
    case 1: variantSetId = (java.lang.CharSequence)value$; break;
    case 2: names = (java.util.List<java.lang.CharSequence>)value$; break;
    case 3: created = (java.lang.Long)value$; break;
    case 4: updated = (java.lang.Long)value$; break;
    case 5: referenceName = (java.lang.CharSequence)value$; break;
    case 6: start = (java.lang.Long)value$; break;
    case 7: end = (java.lang.Long)value$; break;
    case 8: referenceBases = (java.lang.CharSequence)value$; break;
    case 9: alternateBases = (java.util.List<java.lang.CharSequence>)value$; break;
    case 10: alleleIds = (java.util.List<java.lang.CharSequence>)value$; break;
    case 11: info = (java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>>)value$; break;
    case 12: calls = (java.util.List<org.ga4gh.models.Call>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'id' field.
   * The variant ID.   */
  public java.lang.CharSequence getId() {
    return id;
  }

  /**
   * Sets the value of the 'id' field.
   * The variant ID.   * @param value the value to set.
   */
  public void setId(java.lang.CharSequence value) {
    this.id = value;
  }

  /**
   * Gets the value of the 'variantSetId' field.
   * The ID of the variant set this variant belongs to.   */
  public java.lang.CharSequence getVariantSetId() {
    return variantSetId;
  }

  /**
   * Sets the value of the 'variantSetId' field.
   * The ID of the variant set this variant belongs to.   * @param value the value to set.
   */
  public void setVariantSetId(java.lang.CharSequence value) {
    this.variantSetId = value;
  }

  /**
   * Gets the value of the 'names' field.
   * Names for the variant, for example a RefSNP ID.   */
  public java.util.List<java.lang.CharSequence> getNames() {
    return names;
  }

  /**
   * Sets the value of the 'names' field.
   * Names for the variant, for example a RefSNP ID.   * @param value the value to set.
   */
  public void setNames(java.util.List<java.lang.CharSequence> value) {
    this.names = value;
  }

  /**
   * Gets the value of the 'created' field.
   * The date this variant was created in milliseconds from the epoch.   */
  public java.lang.Long getCreated() {
    return created;
  }

  /**
   * Sets the value of the 'created' field.
   * The date this variant was created in milliseconds from the epoch.   * @param value the value to set.
   */
  public void setCreated(java.lang.Long value) {
    this.created = value;
  }

  /**
   * Gets the value of the 'updated' field.
   * The time at which this variant was last updated in
  milliseconds from the epoch.   */
  public java.lang.Long getUpdated() {
    return updated;
  }

  /**
   * Sets the value of the 'updated' field.
   * The time at which this variant was last updated in
  milliseconds from the epoch.   * @param value the value to set.
   */
  public void setUpdated(java.lang.Long value) {
    this.updated = value;
  }

  /**
   * Gets the value of the 'referenceName' field.
   * The reference on which this variant occurs.
  (e.g. `chr20` or `X`)

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.lang.CharSequence getReferenceName() {
    return referenceName;
  }

  /**
   * Sets the value of the 'referenceName' field.
   * The reference on which this variant occurs.
  (e.g. `chr20` or `X`)

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setReferenceName(java.lang.CharSequence value) {
    this.referenceName = value;
  }

  /**
   * Gets the value of the 'start' field.
   * The start position at which this variant occurs (0-based).
  This corresponds to the first base of the string of reference bases.
  Genomic positions are non-negative integers less than reference length.
  Variants spanning the join of circular genomes are represented as
  two variants one on each side of the join (position 0).

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.lang.Long getStart() {
    return start;
  }

  /**
   * Sets the value of the 'start' field.
   * The start position at which this variant occurs (0-based).
  This corresponds to the first base of the string of reference bases.
  Genomic positions are non-negative integers less than reference length.
  Variants spanning the join of circular genomes are represented as
  two variants one on each side of the join (position 0).

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setStart(java.lang.Long value) {
    this.start = value;
  }

  /**
   * Gets the value of the 'end' field.
   * The end position (exclusive), resulting in [start, end) closed-open interval.
  This is typically calculated by `start + referenceBases.length`.

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.lang.Long getEnd() {
    return end;
  }

  /**
   * Sets the value of the 'end' field.
   * The end position (exclusive), resulting in [start, end) closed-open interval.
  This is typically calculated by `start + referenceBases.length`.

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setEnd(java.lang.Long value) {
    this.end = value;
  }

  /**
   * Gets the value of the 'referenceBases' field.
   * The reference bases for this variant. They occupy the range described by
  `referenceName`, `start`, and `end`, which all must be set if this field is
  set.

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.lang.CharSequence getReferenceBases() {
    return referenceBases;
  }

  /**
   * Sets the value of the 'referenceBases' field.
   * The reference bases for this variant. They occupy the range described by
  `referenceName`, `start`, and `end`, which all must be set if this field is
  set.

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setReferenceBases(java.lang.CharSequence value) {
    this.referenceBases = value;
  }

  /**
   * Gets the value of the 'alternateBases' field.
   * The bases that appear instead of the reference bases. If this field is not
  null, `referenceBases` must be set.

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.util.List<java.lang.CharSequence> getAlternateBases() {
    return alternateBases;
  }

  /**
   * Sets the value of the 'alternateBases' field.
   * The bases that appear instead of the reference bases. If this field is not
  null, `referenceBases` must be set.

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setAlternateBases(java.util.List<java.lang.CharSequence> value) {
    this.alternateBases = value;
  }

  /**
   * Gets the value of the 'alleleIds' field.
   * The IDs of the reference and alternate `Allele`s for this `Variant`. The first
  is the reference allele, and any others are alternates. If this field is set
  along with `referenceName`, `start`, `end`, `referenceBases`, and/or
  `alternateBases`, those fields must agree with the `Allele`s given here.

  If the API server supports the "graph" mode, this field must not be null.   */
  public java.util.List<java.lang.CharSequence> getAlleleIds() {
    return alleleIds;
  }

  /**
   * Sets the value of the 'alleleIds' field.
   * The IDs of the reference and alternate `Allele`s for this `Variant`. The first
  is the reference allele, and any others are alternates. If this field is set
  along with `referenceName`, `start`, `end`, `referenceBases`, and/or
  `alternateBases`, those fields must agree with the `Allele`s given here.

  If the API server supports the "graph" mode, this field must not be null.   * @param value the value to set.
   */
  public void setAlleleIds(java.util.List<java.lang.CharSequence> value) {
    this.alleleIds = value;
  }

  /**
   * Gets the value of the 'info' field.
   * A map of additional variant information.   */
  public java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> getInfo() {
    return info;
  }

  /**
   * Sets the value of the 'info' field.
   * A map of additional variant information.   * @param value the value to set.
   */
  public void setInfo(java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> value) {
    this.info = value;
  }

  /**
   * Gets the value of the 'calls' field.
   * The variant calls for this particular variant. Each one represents the
  determination of genotype with respect to this variant. `Call`s in this array
  are implicitly associated with this `Variant`.

  Calls are also available through the `searchCalls()` API method.

  If the API server supports the "classic" mode, this field must not be null.   */
  public java.util.List<org.ga4gh.models.Call> getCalls() {
    return calls;
  }

  /**
   * Sets the value of the 'calls' field.
   * The variant calls for this particular variant. Each one represents the
  determination of genotype with respect to this variant. `Call`s in this array
  are implicitly associated with this `Variant`.

  Calls are also available through the `searchCalls()` API method.

  If the API server supports the "classic" mode, this field must not be null.   * @param value the value to set.
   */
  public void setCalls(java.util.List<org.ga4gh.models.Call> value) {
    this.calls = value;
  }

  /** Creates a new Variant RecordBuilder */
  public static org.ga4gh.models.Variant.Builder newBuilder() {
    return new org.ga4gh.models.Variant.Builder();
  }
  
  /** Creates a new Variant RecordBuilder by copying an existing Builder */
  public static org.ga4gh.models.Variant.Builder newBuilder(org.ga4gh.models.Variant.Builder other) {
    return new org.ga4gh.models.Variant.Builder(other);
  }
  
  /** Creates a new Variant RecordBuilder by copying an existing Variant instance */
  public static org.ga4gh.models.Variant.Builder newBuilder(org.ga4gh.models.Variant other) {
    return new org.ga4gh.models.Variant.Builder(other);
  }
  
  /**
   * RecordBuilder for Variant instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<Variant>
    implements org.apache.avro.data.RecordBuilder<Variant> {

    private java.lang.CharSequence id;
    private java.lang.CharSequence variantSetId;
    private java.util.List<java.lang.CharSequence> names;
    private java.lang.Long created;
    private java.lang.Long updated;
    private java.lang.CharSequence referenceName;
    private java.lang.Long start;
    private java.lang.Long end;
    private java.lang.CharSequence referenceBases;
    private java.util.List<java.lang.CharSequence> alternateBases;
    private java.util.List<java.lang.CharSequence> alleleIds;
    private java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> info;
    private java.util.List<org.ga4gh.models.Call> calls;

    /** Creates a new Builder */
    private Builder() {
      super(org.ga4gh.models.Variant.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.ga4gh.models.Variant.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.variantSetId)) {
        this.variantSetId = data().deepCopy(fields()[1].schema(), other.variantSetId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.names)) {
        this.names = data().deepCopy(fields()[2].schema(), other.names);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.created)) {
        this.created = data().deepCopy(fields()[3].schema(), other.created);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.updated)) {
        this.updated = data().deepCopy(fields()[4].schema(), other.updated);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.referenceName)) {
        this.referenceName = data().deepCopy(fields()[5].schema(), other.referenceName);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.start)) {
        this.start = data().deepCopy(fields()[6].schema(), other.start);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.end)) {
        this.end = data().deepCopy(fields()[7].schema(), other.end);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.referenceBases)) {
        this.referenceBases = data().deepCopy(fields()[8].schema(), other.referenceBases);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alternateBases)) {
        this.alternateBases = data().deepCopy(fields()[9].schema(), other.alternateBases);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.alleleIds)) {
        this.alleleIds = data().deepCopy(fields()[10].schema(), other.alleleIds);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.info)) {
        this.info = data().deepCopy(fields()[11].schema(), other.info);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.calls)) {
        this.calls = data().deepCopy(fields()[12].schema(), other.calls);
        fieldSetFlags()[12] = true;
      }
    }
    
    /** Creates a Builder by copying an existing Variant instance */
    private Builder(org.ga4gh.models.Variant other) {
            super(org.ga4gh.models.Variant.SCHEMA$);
      if (isValidValue(fields()[0], other.id)) {
        this.id = data().deepCopy(fields()[0].schema(), other.id);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.variantSetId)) {
        this.variantSetId = data().deepCopy(fields()[1].schema(), other.variantSetId);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.names)) {
        this.names = data().deepCopy(fields()[2].schema(), other.names);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.created)) {
        this.created = data().deepCopy(fields()[3].schema(), other.created);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.updated)) {
        this.updated = data().deepCopy(fields()[4].schema(), other.updated);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.referenceName)) {
        this.referenceName = data().deepCopy(fields()[5].schema(), other.referenceName);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.start)) {
        this.start = data().deepCopy(fields()[6].schema(), other.start);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.end)) {
        this.end = data().deepCopy(fields()[7].schema(), other.end);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.referenceBases)) {
        this.referenceBases = data().deepCopy(fields()[8].schema(), other.referenceBases);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.alternateBases)) {
        this.alternateBases = data().deepCopy(fields()[9].schema(), other.alternateBases);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.alleleIds)) {
        this.alleleIds = data().deepCopy(fields()[10].schema(), other.alleleIds);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.info)) {
        this.info = data().deepCopy(fields()[11].schema(), other.info);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.calls)) {
        this.calls = data().deepCopy(fields()[12].schema(), other.calls);
        fieldSetFlags()[12] = true;
      }
    }

    /** Gets the value of the 'id' field */
    public java.lang.CharSequence getId() {
      return id;
    }
    
    /** Sets the value of the 'id' field */
    public org.ga4gh.models.Variant.Builder setId(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.id = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'id' field has been set */
    public boolean hasId() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'id' field */
    public org.ga4gh.models.Variant.Builder clearId() {
      id = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'variantSetId' field */
    public java.lang.CharSequence getVariantSetId() {
      return variantSetId;
    }
    
    /** Sets the value of the 'variantSetId' field */
    public org.ga4gh.models.Variant.Builder setVariantSetId(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.variantSetId = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'variantSetId' field has been set */
    public boolean hasVariantSetId() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'variantSetId' field */
    public org.ga4gh.models.Variant.Builder clearVariantSetId() {
      variantSetId = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'names' field */
    public java.util.List<java.lang.CharSequence> getNames() {
      return names;
    }
    
    /** Sets the value of the 'names' field */
    public org.ga4gh.models.Variant.Builder setNames(java.util.List<java.lang.CharSequence> value) {
      validate(fields()[2], value);
      this.names = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'names' field has been set */
    public boolean hasNames() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'names' field */
    public org.ga4gh.models.Variant.Builder clearNames() {
      names = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'created' field */
    public java.lang.Long getCreated() {
      return created;
    }
    
    /** Sets the value of the 'created' field */
    public org.ga4gh.models.Variant.Builder setCreated(java.lang.Long value) {
      validate(fields()[3], value);
      this.created = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'created' field has been set */
    public boolean hasCreated() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'created' field */
    public org.ga4gh.models.Variant.Builder clearCreated() {
      created = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'updated' field */
    public java.lang.Long getUpdated() {
      return updated;
    }
    
    /** Sets the value of the 'updated' field */
    public org.ga4gh.models.Variant.Builder setUpdated(java.lang.Long value) {
      validate(fields()[4], value);
      this.updated = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'updated' field has been set */
    public boolean hasUpdated() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'updated' field */
    public org.ga4gh.models.Variant.Builder clearUpdated() {
      updated = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'referenceName' field */
    public java.lang.CharSequence getReferenceName() {
      return referenceName;
    }
    
    /** Sets the value of the 'referenceName' field */
    public org.ga4gh.models.Variant.Builder setReferenceName(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.referenceName = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'referenceName' field has been set */
    public boolean hasReferenceName() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'referenceName' field */
    public org.ga4gh.models.Variant.Builder clearReferenceName() {
      referenceName = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'start' field */
    public java.lang.Long getStart() {
      return start;
    }
    
    /** Sets the value of the 'start' field */
    public org.ga4gh.models.Variant.Builder setStart(java.lang.Long value) {
      validate(fields()[6], value);
      this.start = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'start' field has been set */
    public boolean hasStart() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'start' field */
    public org.ga4gh.models.Variant.Builder clearStart() {
      start = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'end' field */
    public java.lang.Long getEnd() {
      return end;
    }
    
    /** Sets the value of the 'end' field */
    public org.ga4gh.models.Variant.Builder setEnd(java.lang.Long value) {
      validate(fields()[7], value);
      this.end = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'end' field has been set */
    public boolean hasEnd() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'end' field */
    public org.ga4gh.models.Variant.Builder clearEnd() {
      end = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'referenceBases' field */
    public java.lang.CharSequence getReferenceBases() {
      return referenceBases;
    }
    
    /** Sets the value of the 'referenceBases' field */
    public org.ga4gh.models.Variant.Builder setReferenceBases(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.referenceBases = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'referenceBases' field has been set */
    public boolean hasReferenceBases() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'referenceBases' field */
    public org.ga4gh.models.Variant.Builder clearReferenceBases() {
      referenceBases = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'alternateBases' field */
    public java.util.List<java.lang.CharSequence> getAlternateBases() {
      return alternateBases;
    }
    
    /** Sets the value of the 'alternateBases' field */
    public org.ga4gh.models.Variant.Builder setAlternateBases(java.util.List<java.lang.CharSequence> value) {
      validate(fields()[9], value);
      this.alternateBases = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'alternateBases' field has been set */
    public boolean hasAlternateBases() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'alternateBases' field */
    public org.ga4gh.models.Variant.Builder clearAlternateBases() {
      alternateBases = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'alleleIds' field */
    public java.util.List<java.lang.CharSequence> getAlleleIds() {
      return alleleIds;
    }
    
    /** Sets the value of the 'alleleIds' field */
    public org.ga4gh.models.Variant.Builder setAlleleIds(java.util.List<java.lang.CharSequence> value) {
      validate(fields()[10], value);
      this.alleleIds = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'alleleIds' field has been set */
    public boolean hasAlleleIds() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'alleleIds' field */
    public org.ga4gh.models.Variant.Builder clearAlleleIds() {
      alleleIds = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'info' field */
    public java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> getInfo() {
      return info;
    }
    
    /** Sets the value of the 'info' field */
    public org.ga4gh.models.Variant.Builder setInfo(java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>> value) {
      validate(fields()[11], value);
      this.info = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'info' field has been set */
    public boolean hasInfo() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'info' field */
    public org.ga4gh.models.Variant.Builder clearInfo() {
      info = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'calls' field */
    public java.util.List<org.ga4gh.models.Call> getCalls() {
      return calls;
    }
    
    /** Sets the value of the 'calls' field */
    public org.ga4gh.models.Variant.Builder setCalls(java.util.List<org.ga4gh.models.Call> value) {
      validate(fields()[12], value);
      this.calls = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'calls' field has been set */
    public boolean hasCalls() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'calls' field */
    public org.ga4gh.models.Variant.Builder clearCalls() {
      calls = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    @Override
    public Variant build() {
      try {
        Variant record = new Variant();
        record.id = fieldSetFlags()[0] ? this.id : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.variantSetId = fieldSetFlags()[1] ? this.variantSetId : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.names = fieldSetFlags()[2] ? this.names : (java.util.List<java.lang.CharSequence>) defaultValue(fields()[2]);
        record.created = fieldSetFlags()[3] ? this.created : (java.lang.Long) defaultValue(fields()[3]);
        record.updated = fieldSetFlags()[4] ? this.updated : (java.lang.Long) defaultValue(fields()[4]);
        record.referenceName = fieldSetFlags()[5] ? this.referenceName : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.start = fieldSetFlags()[6] ? this.start : (java.lang.Long) defaultValue(fields()[6]);
        record.end = fieldSetFlags()[7] ? this.end : (java.lang.Long) defaultValue(fields()[7]);
        record.referenceBases = fieldSetFlags()[8] ? this.referenceBases : (java.lang.CharSequence) defaultValue(fields()[8]);
        record.alternateBases = fieldSetFlags()[9] ? this.alternateBases : (java.util.List<java.lang.CharSequence>) defaultValue(fields()[9]);
        record.alleleIds = fieldSetFlags()[10] ? this.alleleIds : (java.util.List<java.lang.CharSequence>) defaultValue(fields()[10]);
        record.info = fieldSetFlags()[11] ? this.info : (java.util.Map<java.lang.CharSequence,java.util.List<java.lang.CharSequence>>) defaultValue(fields()[11]);
        record.calls = fieldSetFlags()[12] ? this.calls : (java.util.List<org.ga4gh.models.Call>) defaultValue(fields()[12]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
